<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tailer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons IO</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.io.input</a> &gt; <span class="el_source">Tailer.java</span></div><h1>Tailer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.io.input;

import static org.apache.commons.io.IOUtils.CR;
import static org.apache.commons.io.IOUtils.EOF;
import static org.apache.commons.io.IOUtils.LF;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.attribute.FileTime;
import java.time.Duration;
import java.util.Arrays;
import java.util.Objects;

import org.apache.commons.io.IOUtils;
import org.apache.commons.io.ThreadUtils;
import org.apache.commons.io.build.AbstractOrigin;
import org.apache.commons.io.build.AbstractStreamBuilder;
import org.apache.commons.io.file.PathUtils;
import org.apache.commons.io.file.attribute.FileTimes;

/**
 * Simple implementation of the UNIX &quot;tail -f&quot; functionality.
 *
 * &lt;h2&gt;1. Create a TailerListener implementation&lt;/h2&gt;
 * &lt;p&gt;
 * First you need to create a {@link TailerListener} implementation; ({@link TailerListenerAdapter} is provided for
 * convenience so that you don't have to implement every method).
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * For example:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * public class MyTailerListener extends TailerListenerAdapter {
 *     public void handle(String line) {
 *         System.out.println(line);
 *     }
 * }
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;2. Using a Tailer&lt;/h2&gt;
 *
 * &lt;p&gt;
 * You can create and use a Tailer in one of three ways:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Using a {@link Builder}&lt;/li&gt;
 * &lt;li&gt;Using an {@link java.util.concurrent.Executor}&lt;/li&gt;
 * &lt;li&gt;Using a {@link Thread}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * An example of each is shown below.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;2.1 Using a Builder&lt;/h3&gt;
 *
 * &lt;pre&gt;
 * TailerListener listener = new MyTailerListener();
 * Tailer tailer = Tailer.builder()
 *   .setFile(file)
 *   .setTailerListener(listener)
 *   .setDelayDuration(delay)
 *   .get();
 * &lt;/pre&gt;
 *
 * &lt;h3&gt;2.2 Using an Executor&lt;/h3&gt;
 *
 * &lt;pre&gt;
 * TailerListener listener = new MyTailerListener();
 * Tailer tailer = new Tailer(file, listener, delay);
 *
 * // stupid executor impl. for demo purposes
 * Executor executor = new Executor() {
 *     public void execute(Runnable command) {
 *         command.run();
 *     }
 * };
 *
 * executor.execute(tailer);
 * &lt;/pre&gt;
 *
 *
 * &lt;h3&gt;2.3 Using a Thread&lt;/h3&gt;
 *
 * &lt;pre&gt;
 * TailerListener listener = new MyTailerListener();
 * Tailer tailer = new Tailer(file, listener, delay);
 * Thread thread = new Thread(tailer);
 * thread.setDaemon(true); // optional
 * thread.start();
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;3. Stopping a Tailer&lt;/h2&gt;
 * &lt;p&gt;
 * Remember to stop the tailer when you have done with it:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * tailer.stop();
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;4. Interrupting a Tailer&lt;/h2&gt;
 * &lt;p&gt;
 * You can interrupt the thread a tailer is running on by calling {@link Thread#interrupt()}.
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * thread.interrupt();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * If you interrupt a tailer, the tailer listener is called with the {@link InterruptedException}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The file is read using the default Charset; this can be overridden if necessary.
 * &lt;/p&gt;
 *
 * @see TailerListener
 * @see TailerListenerAdapter
 * @since 2.0
 * @since 2.5 Updated behavior and documentation for {@link Thread#interrupt()}.
 * @since 2.12.0 Add {@link Tailable} and {@link RandomAccessResourceBridge} interfaces to tail of files accessed using
 *        alternative libraries such as jCIFS or &lt;a href=&quot;https://commons.apache.org/proper/commons-vfs/&quot;&gt;Apache Commons
 *        VFS&lt;/a&gt;.
 */
public class Tailer implements Runnable, AutoCloseable {

    /**
     * Builds a {@link Tailer} with default values.
     * &lt;p&gt;
     * For example:
     * &lt;/p&gt;
     * &lt;pre&gt;{@code
     * Tailer t = Tailer.builder()
     *   .setPath(path)
     *   .setCharset(StandardCharsets.UTF_8)
     *   .setDelayDuration(Duration.ofSeconds(1))
     *   .setReOpen(false)
     *   .setStartThread(true)
     *   .setTailable(tailable)
     *   .setTailerListener(tailerListener)
     *   .setTailFromEnd(false)
     *   .get()}
     * &lt;/pre&gt;
     * &lt;p&gt;
     * @since 2.12.0
     */
<span class="fc" id="L173">    public static class Builder extends AbstractStreamBuilder&lt;Tailer, Builder&gt; {</span>

        private Tailable tailable;
        private TailerListener tailerListener;
<span class="fc" id="L177">        private Duration delayDuration = Duration.ofMillis(DEFAULT_DELAY_MILLIS);</span>
        private boolean end;
        private boolean reOpen;
<span class="fc" id="L180">        private boolean startThread = true;</span>
        /**
         * Builds and starts a new configured instance.
         *
         * @return a new configured instance.
         */
        @Override
        public Tailer get() {
<span class="fc" id="L188">            final Tailer tailer = new Tailer(tailable, getCharset(), tailerListener, delayDuration, end, reOpen, getBufferSize());</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if (startThread) {</span>
<span class="fc" id="L190">                final Thread thread = new Thread(tailer);</span>
<span class="fc" id="L191">                thread.setDaemon(true);</span>
<span class="fc" id="L192">                thread.start();</span>
            }
<span class="fc" id="L194">            return tailer;</span>
        }

        /**
         * Sets the delay duration.
         *
         * @param delayDuration the delay between checks of the file for new content.
         * @return this
         */
        public Builder setDelayDuration(final Duration delayDuration) {
<span class="fc" id="L204">            this.delayDuration = Objects.requireNonNull(delayDuration, &quot;delayDuration&quot;);</span>
<span class="fc" id="L205">            return this;</span>
        }

        @Override
        protected Builder setOrigin(final AbstractOrigin&lt;?, ?&gt; origin) {
<span class="fc" id="L210">            setTailable(new TailablePath(origin.getPath()));</span>
<span class="fc" id="L211">            return super.setOrigin(origin);</span>
        }

        /**
         * Sets the re-open behavior.
         *
         * @param reOpen whether to close/reopen the file between chunks
         * @return this
         */
        public Builder setReOpen(final boolean reOpen) {
<span class="fc" id="L221">            this.reOpen = reOpen;</span>
<span class="fc" id="L222">            return this;</span>
        }

        /**
         * Sets the daemon thread startup behavior.
         *
         * @param startThread whether to create a daemon thread automatically.
         * @return this
         */
        public Builder setStartThread(final boolean startThread) {
<span class="nc" id="L232">            this.startThread = startThread;</span>
<span class="nc" id="L233">            return this;</span>
        }

        /**
         * Sets the tailable.
         *
         * @param tailable the tailable.
         * @return this.
         */
        public Builder setTailable(final Tailable tailable) {
<span class="fc" id="L243">            this.tailable = Objects.requireNonNull(tailable, &quot;tailable&quot;);</span>
<span class="fc" id="L244">            return this;</span>
        }

        /**
         * Sets the listener.
         *
         * @param tailerListener the listener.
         * @return this
         */
        public Builder setTailerListener(final TailerListener tailerListener) {
<span class="fc" id="L254">            this.tailerListener = Objects.requireNonNull(tailerListener, &quot;tailerListener&quot;);</span>
<span class="fc" id="L255">            return this;</span>
        }

        /**
         * Sets the tail start behavior.
         *
         * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
         * @return this
         */
        public Builder setTailFromEnd(final boolean end) {
<span class="fc" id="L265">            this.end = end;</span>
<span class="fc" id="L266">            return this;</span>
        }
    }

    /**
     * Bridges random access to a {@link RandomAccessFile}.
     */
    private static final class RandomAccessFileBridge implements RandomAccessResourceBridge {

        private final RandomAccessFile randomAccessFile;

<span class="fc" id="L277">        private RandomAccessFileBridge(final File file, final String mode) throws FileNotFoundException {</span>
<span class="fc" id="L278">            randomAccessFile = new RandomAccessFile(file, mode);</span>
<span class="fc" id="L279">        }</span>

        @Override
        public void close() throws IOException {
<span class="fc" id="L283">            randomAccessFile.close();</span>
<span class="fc" id="L284">        }</span>

        @Override
        public long getPointer() throws IOException {
<span class="fc" id="L288">            return randomAccessFile.getFilePointer();</span>
        }

        @Override
        public int read(final byte[] b) throws IOException {
<span class="fc" id="L293">            return randomAccessFile.read(b);</span>
        }

        @Override
        public void seek(final long position) throws IOException {
<span class="fc" id="L298">            randomAccessFile.seek(position);</span>
<span class="fc" id="L299">        }</span>

    }

    /**
     * Bridges access to a resource for random access, normally a file. Allows substitution of remote files for example
     * using jCIFS.
     *
     * @since 2.12.0
     */
    public interface RandomAccessResourceBridge extends Closeable {

        /**
         * Gets the current offset in this tailable.
         *
         * @return the offset from the beginning of the tailable, in bytes, at which the next read or write occurs.
         * @throws IOException if an I/O error occurs.
         */
        long getPointer() throws IOException;

        /**
         * Reads up to {@code b.length} bytes of data from this tailable into an array of bytes. This method blocks until at
         * least one byte of input is available.
         *
         * @param b the buffer into which the data is read.
         * @return the total number of bytes read into the buffer, or {@code -1} if there is no more data because the end of
         *         this tailable has been reached.
         * @throws IOException If the first byte cannot be read for any reason other than end of tailable, or if the random
         *         access tailable has been closed, or if some other I/O error occurs.
         */
        int read(final byte[] b) throws IOException;

        /**
         * Sets the file-pointer offset, measured from the beginning of this tailable, at which the next read or write occurs.
         * The offset may be set beyond the end of the tailable. Setting the offset beyond the end of the tailable does not
         * change the tailable length. The tailable length will change only by writing after the offset has been set beyond the
         * end of the tailable.
         *
         * @param pos the offset position, measured in bytes from the beginning of the tailable, at which to set the tailable
         *        pointer.
         * @throws IOException if {@code pos} is less than {@code 0} or if an I/O error occurs.
         */
        void seek(final long pos) throws IOException;
    }

    /**
     * A tailable resource like a file.
     *
     * @since 2.12.0
     */
    public interface Tailable {

        /**
         * Creates a random access file stream to read.
         *
         * @param mode the access mode, by default this is for {@link RandomAccessFile}.
         * @return a random access file stream to read.
         * @throws FileNotFoundException if the tailable object does not exist.
         */
        RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException;

        /**
         * Tests if this tailable is newer than the specified {@link FileTime}.
         *
         * @param fileTime the file time reference.
         * @return true if the {@link File} exists and has been modified after the given {@link FileTime}.
         * @throws IOException if an I/O error occurs.
         */
        boolean isNewer(final FileTime fileTime) throws IOException;

        /**
         * Gets the last modification {@link FileTime}.
         *
         * @return See {@link java.nio.file.Files#getLastModifiedTime(Path, LinkOption...)}.
         * @throws IOException if an I/O error occurs.
         */
        FileTime lastModifiedFileTime() throws IOException;

        /**
         * Gets the size of this tailable.
         *
         * @return The size, in bytes, of this tailable, or {@code 0} if the file does not exist. Some operating systems may
         *         return {@code 0} for path names denoting system-dependent entities such as devices or pipes.
         * @throws IOException if an I/O error occurs.
         */
        long size() throws IOException;
    }

    /**
     * A tailable for a file {@link Path}.
     */
    private static final class TailablePath implements Tailable {

        private final Path path;
        private final LinkOption[] linkOptions;

<span class="fc" id="L395">        private TailablePath(final Path path, final LinkOption... linkOptions) {</span>
<span class="fc" id="L396">            this.path = Objects.requireNonNull(path, &quot;path&quot;);</span>
<span class="fc" id="L397">            this.linkOptions = linkOptions;</span>
<span class="fc" id="L398">        }</span>

        Path getPath() {
<span class="nc" id="L401">            return path;</span>
        }

        @Override
        public RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException {
<span class="fc" id="L406">            return new RandomAccessFileBridge(path.toFile(), mode);</span>
        }

        @Override
        public boolean isNewer(final FileTime fileTime) throws IOException {
<span class="fc" id="L411">            return PathUtils.isNewer(path, fileTime, linkOptions);</span>
        }

        @Override
        public FileTime lastModifiedFileTime() throws IOException {
<span class="fc" id="L416">            return Files.getLastModifiedTime(path, linkOptions);</span>
        }

        @Override
        public long size() throws IOException {
<span class="fc" id="L421">            return Files.size(path);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L426">            return &quot;TailablePath [file=&quot; + path + &quot;, linkOptions=&quot; + Arrays.toString(linkOptions) + &quot;]&quot;;</span>
        }
    }

    private static final int DEFAULT_DELAY_MILLIS = 1000;

    private static final String RAF_READ_ONLY_MODE = &quot;r&quot;;

    // The default charset used for reading files
<span class="fc" id="L435">    private static final Charset DEFAULT_CHARSET = Charset.defaultCharset();</span>

    /**
     * Constructs a new {@link Builder}.
     *
     * @return Creates a new {@link Builder}.
     * @since 2.12.0
     */
    public static Builder builder() {
<span class="fc" id="L444">        return new Builder();</span>
    }

    /**
     * Creates and starts a Tailer for the given file.
     *
     * @param file the file to follow.
     * @param charset the character set to use for reading the file.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen whether to close/reopen the file between chunks.
     * @param bufferSize buffer size.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public static Tailer create(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end,
        final boolean reOpen, final int bufferSize) {
        //@formatter:off
<span class="fc" id="L464">        return builder()</span>
<span class="fc" id="L465">                .setFile(file)</span>
<span class="fc" id="L466">                .setTailerListener(listener)</span>
<span class="fc" id="L467">                .setCharset(charset)</span>
<span class="fc" id="L468">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L469">                .setTailFromEnd(end)</span>
<span class="fc" id="L470">                .setReOpen(reOpen)</span>
<span class="fc" id="L471">                .setBufferSize(bufferSize)</span>
<span class="fc" id="L472">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file, starting at the beginning of the file with the default delay of 1.0s
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener) {
        //@formatter:off
<span class="fc" id="L487">        return builder()</span>
<span class="fc" id="L488">                .setFile(file)</span>
<span class="fc" id="L489">                .setTailerListener(listener)</span>
<span class="fc" id="L490">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file, starting at the beginning of the file
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis) {
        //@formatter:off
<span class="fc" id="L506">        return builder()</span>
<span class="fc" id="L507">                .setFile(file)</span>
<span class="fc" id="L508">                .setTailerListener(listener)</span>
<span class="fc" id="L509">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L510">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file with default buffer size.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end) {
        //@formatter:off
<span class="fc" id="L527">        return builder()</span>
<span class="fc" id="L528">                .setFile(file)</span>
<span class="fc" id="L529">                .setTailerListener(listener)</span>
<span class="fc" id="L530">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L531">                .setTailFromEnd(end)</span>
<span class="fc" id="L532">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file with default buffer size.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen whether to close/reopen the file between chunks.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {
        //@formatter:off
<span class="fc" id="L550">        return builder()</span>
<span class="fc" id="L551">                .setFile(file)</span>
<span class="fc" id="L552">                .setTailerListener(listener)</span>
<span class="fc" id="L553">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L554">                .setTailFromEnd(end)</span>
<span class="fc" id="L555">                .setReOpen(reOpen)</span>
<span class="fc" id="L556">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen whether to close/reopen the file between chunks.
     * @param bufferSize buffer size.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,
        final int bufferSize) {
        //@formatter:off
<span class="fc" id="L576">        return builder()</span>
<span class="fc" id="L577">                .setFile(file)</span>
<span class="fc" id="L578">                .setTailerListener(listener)</span>
<span class="fc" id="L579">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L580">                .setTailFromEnd(end)</span>
<span class="fc" id="L581">                .setReOpen(reOpen)</span>
<span class="fc" id="L582">                .setBufferSize(bufferSize)</span>
<span class="fc" id="L583">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param bufferSize buffer size.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {
        //@formatter:off
<span class="fc" id="L601">        return builder()</span>
<span class="fc" id="L602">                .setFile(file)</span>
<span class="fc" id="L603">                .setTailerListener(listener)</span>
<span class="fc" id="L604">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L605">                .setTailFromEnd(end)</span>
<span class="fc" id="L606">                .setBufferSize(bufferSize)</span>
<span class="fc" id="L607">                .get();</span>
        //@formatter:on
    }

    /**
     * Buffer on top of RandomAccessResourceBridge.
     */
    private final byte[] inbuf;

    /**
     * The file which will be tailed.
     */
    private final Tailable tailable;

    /**
     * The character set that will be used to read the file.
     */
    private final Charset charset;

    /**
     * The amount of time to wait for the file to be updated.
     */
    private final Duration delayDuration;

    /**
     * Whether to tail from the end or start of file
     */
    private final boolean tailAtEnd;

    /**
     * The listener to notify of events when tailing.
     */
    private final TailerListener listener;

    /**
     * Whether to close and reopen the file whilst waiting for more input.
     */
    private final boolean reOpen;

    /**
     * The tailer will run as long as this value is true.
     */
<span class="fc" id="L649">    private volatile boolean run = true;</span>

    /**
     * Creates a Tailer for the given file, with a specified buffer size.
     *
     * @param file the file to follow.
     * @param charset the Charset to be used for reading the file
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen if true, close and reopen the file between reading chunks
     * @param bufSize Buffer size
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public Tailer(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,
        final int bufSize) {
<span class="fc" id="L666">        this(new TailablePath(file.toPath()), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize);</span>
<span class="fc" id="L667">    }</span>

    /**
     * Creates a Tailer for the given file, starting from the beginning, with the default delay of 1.0s.
     *
     * @param file The file to follow.
     * @param listener the TailerListener to use.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener) {
<span class="fc" id="L678">        this(file, listener, DEFAULT_DELAY_MILLIS);</span>
<span class="fc" id="L679">    }</span>

    /**
     * Creates a Tailer for the given file, starting from the beginning.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis) {
<span class="fc" id="L691">        this(file, listener, delayMillis, false);</span>
<span class="fc" id="L692">    }</span>

    /**
     * Creates a Tailer for the given file, with a delay other than the default 1.0s.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end) {
<span class="fc" id="L705">        this(file, listener, delayMillis, end, IOUtils.DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L706">    }</span>

    /**
     * Creates a Tailer for the given file, with a delay other than the default 1.0s.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen if true, close and reopen the file between reading chunks
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {
<span class="fc" id="L720">        this(file, listener, delayMillis, end, reOpen, IOUtils.DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L721">    }</span>

    /**
     * Creates a Tailer for the given file, with a specified buffer size.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen if true, close and reopen the file between reading chunks
     * @param bufferSize Buffer size
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufferSize) {
<span class="fc" id="L736">        this(file, DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufferSize);</span>
<span class="fc" id="L737">    }</span>

    /**
     * Creates a Tailer for the given file, with a specified buffer size.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param bufferSize Buffer size
     * @deprecated Use {@link #builder()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {
<span class="fc" id="L751">        this(file, listener, delayMillis, end, false, bufferSize);</span>
<span class="fc" id="L752">    }</span>

    /**
     * Creates a Tailer for the given file, with a specified buffer size.
     *
     * @param tailable the file to follow.
     * @param charset the Charset to be used for reading the file
     * @param listener the TailerListener to use.
     * @param delayDuration the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen if true, close and reopen the file between reading chunks
     * @param bufferSize Buffer size
     */
    private Tailer(final Tailable tailable, final Charset charset, final TailerListener listener, final Duration delayDuration, final boolean end,
<span class="fc" id="L766">        final boolean reOpen, final int bufferSize) {</span>
<span class="fc" id="L767">        this.tailable = Objects.requireNonNull(tailable, &quot;tailable&quot;);</span>
<span class="fc" id="L768">        this.listener = Objects.requireNonNull(listener, &quot;listener&quot;);</span>
<span class="fc" id="L769">        this.delayDuration = delayDuration;</span>
<span class="fc" id="L770">        this.tailAtEnd = end;</span>
<span class="fc" id="L771">        this.inbuf = IOUtils.byteArray(bufferSize);</span>

        // Save and prepare the listener
<span class="fc" id="L774">        listener.init(this);</span>
<span class="fc" id="L775">        this.reOpen = reOpen;</span>
<span class="fc" id="L776">        this.charset = charset;</span>
<span class="fc" id="L777">    }</span>

    /**
     * Requests the tailer to complete its current loop and return.
     */
    @Override
    public void close() {
<span class="fc" id="L784">        this.run = false;</span>
<span class="fc" id="L785">    }</span>

    /**
     * Gets the delay in milliseconds.
     *
     * @return the delay in milliseconds.
     * @deprecated Use {@link #getDelayDuration()}.
     */
    @Deprecated
    public long getDelay() {
<span class="nc" id="L795">        return delayDuration.toMillis();</span>
    }

    /**
     * Gets the delay Duration.
     *
     * @return the delay Duration.
     * @since 2.12.0
     */
    public Duration getDelayDuration() {
<span class="nc" id="L805">        return delayDuration;</span>
    }

    /**
     * Gets the file.
     *
     * @return the file
     * @throws IllegalStateException if constructed using a user provided {@link Tailable} implementation
     */
    public File getFile() {
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if (tailable instanceof TailablePath) {</span>
<span class="nc" id="L816">            return ((TailablePath) tailable).getPath().toFile();</span>
        }
<span class="nc" id="L818">        throw new IllegalStateException(&quot;Cannot extract java.io.File from &quot; + tailable.getClass().getName());</span>
    }

    /**
     * Gets whether to keep on running.
     *
     * @return whether to keep on running.
     * @since 2.5
     */
    protected boolean getRun() {
<span class="fc" id="L828">        return run;</span>
    }

    /**
     * Gets the Tailable.
     *
     * @return the Tailable
     * @since 2.12.0
     */
    public Tailable getTailable() {
<span class="fc" id="L838">        return tailable;</span>
    }

    /**
     * Reads new lines.
     *
     * @param reader The file to read
     * @return The new position after the lines have been read
     * @throws IOException if an I/O error occurs.
     */
    private long readLines(final RandomAccessResourceBridge reader) throws IOException {
<span class="fc" id="L849">        try (ByteArrayOutputStream lineBuf = new ByteArrayOutputStream(64)) {</span>
<span class="fc" id="L850">            long pos = reader.getPointer();</span>
<span class="fc" id="L851">            long rePos = pos; // position to re-read</span>
            int num;
<span class="fc" id="L853">            boolean seenCR = false;</span>
<span class="pc bpc" id="L854" title="1 of 4 branches missed.">            while (getRun() &amp;&amp; (num = reader.read(inbuf)) != EOF) {</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">                for (int i = 0; i &lt; num; i++) {</span>
<span class="fc" id="L856">                    final byte ch = inbuf[i];</span>
<span class="fc bfc" id="L857" title="All 3 branches covered.">                    switch (ch) {</span>
                    case LF:
<span class="fc" id="L859">                        seenCR = false; // swallow CR before LF</span>
<span class="fc" id="L860">                        listener.handle(new String(lineBuf.toByteArray(), charset));</span>
<span class="fc" id="L861">                        lineBuf.reset();</span>
<span class="fc" id="L862">                        rePos = pos + i + 1;</span>
<span class="fc" id="L863">                        break;</span>
                    case CR:
<span class="fc bfc" id="L865" title="All 2 branches covered.">                        if (seenCR) {</span>
<span class="fc" id="L866">                            lineBuf.write(CR);</span>
                        }
<span class="fc" id="L868">                        seenCR = true;</span>
<span class="fc" id="L869">                        break;</span>
                    default:
<span class="fc bfc" id="L871" title="All 2 branches covered.">                        if (seenCR) {</span>
<span class="fc" id="L872">                            seenCR = false; // swallow final CR</span>
<span class="fc" id="L873">                            listener.handle(new String(lineBuf.toByteArray(), charset));</span>
<span class="fc" id="L874">                            lineBuf.reset();</span>
<span class="fc" id="L875">                            rePos = pos + i + 1;</span>
                        }
<span class="fc" id="L877">                        lineBuf.write(ch);</span>
                    }
                }
<span class="fc" id="L880">                pos = reader.getPointer();</span>
            }

<span class="fc" id="L883">            reader.seek(rePos); // Ensure we can re-read if necessary</span>

<span class="pc bpc" id="L885" title="1 of 2 branches missed.">            if (listener instanceof TailerListenerAdapter) {</span>
<span class="fc" id="L886">                ((TailerListenerAdapter) listener).endOfFileReached();</span>
            }

<span class="fc" id="L889">            return rePos;</span>
        }
    }

    /**
     * Follows changes in the file, calling {@link TailerListener#handle(String)} with each new line.
     */
    @Override
    public void run() {
<span class="fc" id="L898">        RandomAccessResourceBridge reader = null;</span>
        try {
<span class="fc" id="L900">            FileTime last = FileTimes.EPOCH; // The last time the file was checked for changes</span>
<span class="fc" id="L901">            long position = 0; // position within the file</span>
            // Open the file
<span class="fc bfc" id="L903" title="All 4 branches covered.">            while (getRun() &amp;&amp; reader == null) {</span>
                try {
<span class="fc" id="L905">                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);</span>
<span class="fc" id="L906">                } catch (final FileNotFoundException e) {</span>
<span class="fc" id="L907">                    listener.fileNotFound();</span>
<span class="fc" id="L908">                }</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">                if (reader == null) {</span>
<span class="fc" id="L910">                    ThreadUtils.sleep(delayDuration);</span>
                } else {
                    // The current position in the file
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">                    position = tailAtEnd ? tailable.size() : 0;</span>
<span class="fc" id="L914">                    last = tailable.lastModifiedFileTime();</span>
<span class="fc" id="L915">                    reader.seek(position);</span>
                }
            }
<span class="fc bfc" id="L918" title="All 2 branches covered.">            while (getRun()) {</span>
<span class="fc" id="L919">                final boolean newer = tailable.isNewer(last); // IO-279, must be done first</span>
                // Check the file length to see if it was rotated
<span class="fc" id="L921">                final long length = tailable.size();</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">                if (length &lt; position) {</span>
                    // File was rotated
<span class="fc" id="L924">                    listener.fileRotated();</span>
                    // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it
                    // successfully
<span class="fc" id="L927">                    try (RandomAccessResourceBridge save = reader) {</span>
<span class="fc" id="L928">                        reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);</span>
                        // At this point, we're sure that the old file is rotated
                        // Finish scanning the old file and then we'll start with the new one
                        try {
<span class="fc" id="L932">                            readLines(save);</span>
<span class="nc" id="L933">                        } catch (final IOException ioe) {</span>
<span class="nc" id="L934">                            listener.handle(ioe);</span>
<span class="fc" id="L935">                        }</span>
<span class="fc" id="L936">                        position = 0;</span>
<span class="nc" id="L937">                    } catch (final FileNotFoundException e) {</span>
                        // in this case we continue to use the previous reader and position values
<span class="nc" id="L939">                        listener.fileNotFound();</span>
<span class="nc" id="L940">                        ThreadUtils.sleep(delayDuration);</span>
<span class="fc" id="L941">                    }</span>
<span class="nc" id="L942">                    continue;</span>
                }
                // File was not rotated
                // See if the file needs to be read again
<span class="fc bfc" id="L946" title="All 2 branches covered.">                if (length &gt; position) {</span>
                    // The file has more content than it did last time
<span class="fc" id="L948">                    position = readLines(reader);</span>
<span class="fc" id="L949">                    last = tailable.lastModifiedFileTime();</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">                } else if (newer) {</span>
                    /*
                     * This can happen if the file is truncated or overwritten with the exact same length of information. In cases like
                     * this, the file position needs to be reset
                     */
<span class="fc" id="L955">                    position = 0;</span>
<span class="fc" id="L956">                    reader.seek(position); // cannot be null here</span>

                    // Now we can read new lines
<span class="fc" id="L959">                    position = readLines(reader);</span>
<span class="fc" id="L960">                    last = tailable.lastModifiedFileTime();</span>
                }
<span class="pc bpc" id="L962" title="1 of 4 branches missed.">                if (reOpen &amp;&amp; reader != null) {</span>
<span class="fc" id="L963">                    reader.close();</span>
                }
<span class="fc" id="L965">                ThreadUtils.sleep(delayDuration);</span>
<span class="fc bfc" id="L966" title="All 4 branches covered.">                if (getRun() &amp;&amp; reOpen) {</span>
<span class="fc" id="L967">                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);</span>
<span class="fc" id="L968">                    reader.seek(position);</span>
                }
<span class="fc" id="L970">            }</span>
<span class="fc" id="L971">        } catch (final InterruptedException e) {</span>
<span class="fc" id="L972">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L973">            listener.handle(e);</span>
<span class="nc" id="L974">        } catch (final Exception e) {</span>
<span class="nc" id="L975">            listener.handle(e);</span>
        } finally {
            try {
<span class="fc" id="L978">                IOUtils.close(reader);</span>
<span class="nc" id="L979">            } catch (final IOException e) {</span>
<span class="nc" id="L980">                listener.handle(e);</span>
<span class="fc" id="L981">            }</span>
<span class="fc" id="L982">            close();</span>
        }
<span class="fc" id="L984">    }</span>

    /**
     * Requests the tailer to complete its current loop and return.
     *
     * @deprecated Use {@link #close()}.
     */
    @Deprecated
    public void stop() {
<span class="nc" id="L993">        close();</span>
<span class="nc" id="L994">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>